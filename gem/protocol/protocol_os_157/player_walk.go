// NOT Generated by bbc (but should be in future)
package protocol_os_157

import (
	"io"

	"github.com/gemrs/gem/gem/core/encoding"
	"github.com/gemrs/gem/gem/protocol"
)

// +gen define_inbound:"Pkt164,SzVar8"
type InboundPlayerWalk protocol.InboundPlayerWalk

func (struc *InboundPlayerWalk) Decode(buf io.Reader, flags interface{}) {
	decodeWalk(buf, flags, (*protocol.InboundPlayerWalk)(struc))
}

// +gen define_inbound:"Pkt248,SzVar8,InboundPlayerWalk"
type InboundPlayerWalkMap protocol.InboundPlayerWalk

func (struc *InboundPlayerWalkMap) Decode(buf io.Reader, flags interface{}) {
	decodeWalk(buf, flags, (*protocol.InboundPlayerWalk)(struc))
}

// +gen define_inbound:"Pkt98,SzVar8,InboundPlayerWalk"
type InboundPlayerWalkEntity protocol.InboundPlayerWalk

func (struc *InboundPlayerWalkEntity) Decode(buf io.Reader, flags interface{}) {
	decodeWalk(buf, flags, (*protocol.InboundPlayerWalk)(struc))
}

func decodeWalk(buf io.Reader, flags interface{}, struc *protocol.InboundPlayerWalk) {
	header := flags.(*PacketHeader)
	if header.Number == InboundPlayerWalkMapDefinition.Number {
		// The map walk packet appends 14 extra bytes
		// Not sure what it is yet. Maybe anti-cheat stuff. It's in method92. Ignore it for now.
		header.Size -= 14
	}

	waypointCount := int((header.Size - 5) / 2)
	struc.Waypoints = make([]protocol.WalkWaypoint, waypointCount)

	var tmp16 encoding.Int16
	var tmp8 encoding.Int8

	tmp16.Decode(buf, encoding.IntegerFlag(encoding.IntLittleEndian|encoding.IntOffset128))
	struc.OriginX = int(tmp16)

	for i := 0; i < waypointCount; i++ {
		tmp8.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
		struc.Waypoints[i].X = int(tmp8)
		tmp8.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
		struc.Waypoints[i].Y = int(tmp8)
	}

	tmp16.Decode(buf, encoding.IntegerFlag(encoding.IntLittleEndian))
	struc.OriginY = int(tmp16)

	tmp8.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
	struc.Running = int(tmp8) == 1

	if header.Number == InboundPlayerWalkMapDefinition.Number {
		// ignore the extra 14 bytes for now
		buf.Read(make([]byte, 14))
	}
}
