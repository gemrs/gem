// NOT Generated by bbc (but should be in future)
package game_protocol

import (
	"io"

	"github.com/gemrs/gem/gem/encoding"
)

type Waypoint struct {
	X, Y encoding.Int8
}

type InboundPlayerWalkBlock struct {
	OriginX   encoding.Int16
	Waypoints []Waypoint
	OriginY   encoding.Int16
	Running   encoding.Int8
}

func (struc *InboundPlayerWalkBlock) Encode(w io.Writer, flags interface{}) error {
	panic("not implemented")
}

func (struc *InboundPlayerWalkBlock) Decode(buf io.Reader, flags interface{}) (err error) {
	header := flags.(*encoding.PacketHeader)
	if header.Number == InboundPlayerWalkMapDefinition.Number {
		// The map walk packet appends 14 extra bytes
		// Not sure what it is yet. Maybe anti-cheat stuff. It's in method92. Ignore it for now.
		header.Size -= 14
	}

	waypointCount := int((header.Size - 5) / 2)
	struc.Waypoints = make([]Waypoint, waypointCount)

	err = struc.OriginX.Decode(buf, encoding.IntegerFlag(encoding.IntLittleEndian|encoding.IntOffset128))
	if err != nil {
		return err
	}

	for i := 0; i < waypointCount; i++ {
		err = struc.Waypoints[i].X.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
		if err != nil {
			return err
		}

		err = struc.Waypoints[i].Y.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
		if err != nil {
			return err
		}
	}

	err = struc.OriginY.Decode(buf, encoding.IntegerFlag(encoding.IntLittleEndian))
	if err != nil {
		return err
	}

	err = struc.Running.Decode(buf, encoding.IntegerFlag(encoding.IntNilFlag))
	if err != nil {
		return err
	}

	// ignore the extra 14 bytes for now
	buf.Read(make([]byte, 14))

	return nil
}

type InboundPlayerWalk InboundPlayerWalkBlock

var InboundPlayerWalkDefinition = encoding.PacketHeader{
	Type:   (*InboundPlayerWalk)(nil),
	Number: 164,
	Size:   encoding.SzVar8,
}

func (frm *InboundPlayerWalk) Encode(buf io.Writer, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkDefinition.Number,
		Size:   InboundPlayerWalkDefinition.Size,
		Object: struc,
	}
	return hdr.Encode(buf, flags)
}

func (frm *InboundPlayerWalk) Decode(buf io.Reader, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkDefinition.Number,
		Size:   InboundPlayerWalkDefinition.Size,
		Object: struc,
	}
	return hdr.Decode(buf, flags)
}

type InboundPlayerWalkMap InboundPlayerWalkBlock

var InboundPlayerWalkMapDefinition = encoding.PacketHeader{
	Type:   (*InboundPlayerWalkMap)(nil),
	Number: 248,
	Size:   encoding.SzVar8,
}

func (frm *InboundPlayerWalkMap) Encode(buf io.Writer, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkMapDefinition.Number,
		Size:   InboundPlayerWalkMapDefinition.Size,
		Object: struc,
	}
	return hdr.Encode(buf, flags)
}

func (frm *InboundPlayerWalkMap) Decode(buf io.Reader, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkMapDefinition.Number,
		Size:   InboundPlayerWalkMapDefinition.Size,
		Object: struc,
	}
	return hdr.Decode(buf, flags)
}

type InboundPlayerWalkEntity InboundPlayerWalkBlock

var InboundPlayerWalkEntityDefinition = encoding.PacketHeader{
	Type:   (*InboundPlayerWalkEntity)(nil),
	Number: 98,
	Size:   encoding.SzVar8,
}

func (frm *InboundPlayerWalkEntity) Encode(buf io.Writer, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkEntityDefinition.Number,
		Size:   InboundPlayerWalkEntityDefinition.Size,
		Object: struc,
	}
	return hdr.Encode(buf, flags)
}

func (frm *InboundPlayerWalkEntity) Decode(buf io.Reader, flags interface{}) (err error) {
	struc := (*InboundPlayerWalkBlock)(frm)
	hdr := encoding.PacketHeader{
		Number: InboundPlayerWalkEntityDefinition.Number,
		Size:   InboundPlayerWalkEntityDefinition.Size,
		Object: struc,
	}
	return hdr.Decode(buf, flags)
}
