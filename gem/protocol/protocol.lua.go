// Code generated by glua; DO NOT EDIT.
package protocol

import (
	"github.com/gemrs/gem/glua"
	lua "github.com/yuin/gopher-lua"
)

// Bindprotocol generates a lua binding for protocol
func Bindprotocol(L *lua.LState) {
	L.PreloadModule("gem.game.protocol", lBindprotocol)
}

// lBindprotocol generates the table for the protocol module
func lBindprotocol(L *lua.LState) int {
	mod := L.NewTable()

	lBindAuthResponse(L, mod)

	lBindRights(L, mod)

	lBindSkillId(L, mod)

	L.SetField(mod, "auth_attempts_exceeded", glua.ToLua(L, AuthAttemptsExceeded))

	L.SetField(mod, "auth_bad_session_id", glua.ToLua(L, AuthBadSessionId))

	L.SetField(mod, "auth_delay", glua.ToLua(L, AuthDelay))

	L.SetField(mod, "auth_disabled", glua.ToLua(L, AuthDisabled))

	L.SetField(mod, "auth_duplicate_session", glua.ToLua(L, AuthDuplicateSession))

	L.SetField(mod, "auth_end", glua.ToLua(L, AuthEnd))

	L.SetField(mod, "auth_incomplete", glua.ToLua(L, AuthIncomplete))

	L.SetField(mod, "auth_invalid_credentials", glua.ToLua(L, AuthInvalidCredentials))

	L.SetField(mod, "auth_invalid_login_server", glua.ToLua(L, AuthInvalidLoginServer))

	L.SetField(mod, "auth_invalid_transferring", glua.ToLua(L, AuthInvalidTransferring))

	L.SetField(mod, "auth_members_area", glua.ToLua(L, AuthMembersArea))

	L.SetField(mod, "auth_members_world", glua.ToLua(L, AuthMembersWorld))

	L.SetField(mod, "auth_no_login_server", glua.ToLua(L, AuthNoLoginServer))

	L.SetField(mod, "auth_okay", glua.ToLua(L, AuthOkay))

	L.SetField(mod, "auth_pending", glua.ToLua(L, AuthPending))

	L.SetField(mod, "auth_rejected", glua.ToLua(L, AuthRejected))

	L.SetField(mod, "auth_server_full", glua.ToLua(L, AuthServerFull))

	L.SetField(mod, "auth_too_many_connections", glua.ToLua(L, AuthTooManyConnections))

	L.SetField(mod, "auth_unknown", glua.ToLua(L, AuthUnknown))

	L.SetField(mod, "auth_updates", glua.ToLua(L, AuthUpdates))

	L.SetField(mod, "auth_updating", glua.ToLua(L, AuthUpdating))

	L.SetField(mod, "rights_admin", glua.ToLua(L, RightsAdmin))

	L.SetField(mod, "rights_moderator", glua.ToLua(L, RightsModerator))

	L.SetField(mod, "rights_player", glua.ToLua(L, RightsPlayer))

	L.SetField(mod, "skill_agility", glua.ToLua(L, SkillAgility))

	L.SetField(mod, "skill_attack", glua.ToLua(L, SkillAttack))

	L.SetField(mod, "skill_cooking", glua.ToLua(L, SkillCooking))

	L.SetField(mod, "skill_crafting", glua.ToLua(L, SkillCrafting))

	L.SetField(mod, "skill_defence", glua.ToLua(L, SkillDefence))

	L.SetField(mod, "skill_farming", glua.ToLua(L, SkillFarming))

	L.SetField(mod, "skill_firemaking", glua.ToLua(L, SkillFiremaking))

	L.SetField(mod, "skill_fishing", glua.ToLua(L, SkillFishing))

	L.SetField(mod, "skill_fletching", glua.ToLua(L, SkillFletching))

	L.SetField(mod, "skill_herblore", glua.ToLua(L, SkillHerblore))

	L.SetField(mod, "skill_hitpoints", glua.ToLua(L, SkillHitpoints))

	L.SetField(mod, "skill_magic", glua.ToLua(L, SkillMagic))

	L.SetField(mod, "skill_mining", glua.ToLua(L, SkillMining))

	L.SetField(mod, "skill_prayer", glua.ToLua(L, SkillPrayer))

	L.SetField(mod, "skill_range", glua.ToLua(L, SkillRange))

	L.SetField(mod, "skill_runecrafting", glua.ToLua(L, SkillRunecrafting))

	L.SetField(mod, "skill_slayer", glua.ToLua(L, SkillSlayer))

	L.SetField(mod, "skill_smithing", glua.ToLua(L, SkillSmithing))

	L.SetField(mod, "skill_strength", glua.ToLua(L, SkillStrength))

	L.SetField(mod, "skill_thieving", glua.ToLua(L, SkillThieving))

	L.SetField(mod, "skill_woodcutting", glua.ToLua(L, SkillWoodcutting))

	L.Push(mod)
	return 1
}

func lBindAuthResponse(L *lua.LState, mod *lua.LTable) {
	mt := L.NewTypeMetatable("protocol.AuthResponse")

	L.SetField(mt, "__call", L.NewFunction(lNewAuthResponse))

	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), AuthResponseMethods))

	cls := L.NewUserData()
	L.SetField(mod, "AuthResponse", cls)
	L.SetMetatable(cls, mt)
	glua.RegisterType("protocol.AuthResponse", mt)
}

func lNewAuthResponse(L *lua.LState) int {
	L.Remove(1)
	arg0Value := L.Get(1)
	arg0 := glua.FromLua(arg0Value).(int)
	L.Remove(1)
	retVal := NewAuthResponse(arg0)
	L.Push(glua.ToLua(L, retVal))
	return 1

}

var AuthResponseMethods = map[string]lua.LGFunction{}

func lBindRights(L *lua.LState, mod *lua.LTable) {
	mt := L.NewTypeMetatable("protocol.Rights")

	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), RightsMethods))

	cls := L.NewUserData()
	L.SetField(mod, "Rights", cls)
	L.SetMetatable(cls, mt)
	glua.RegisterType("protocol.Rights", mt)
}

var RightsMethods = map[string]lua.LGFunction{}

func lBindSkillId(L *lua.LState, mod *lua.LTable) {
	mt := L.NewTypeMetatable("protocol.SkillId")

	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), SkillIdMethods))

	cls := L.NewUserData()
	L.SetField(mod, "SkillId", cls)
	L.SetMetatable(cls, mt)
	glua.RegisterType("protocol.SkillId", mt)
}

var SkillIdMethods = map[string]lua.LGFunction{}
